{
  "Angular.html": [
    "Основные концепции Angular Лекция: Основные концепции Angular Введение Приветствую всех! Сегодня мы подробно рассмотрим некоторые ключевые концепции Angular, которые помогут вам создавать масштабируемые, организованные и эффективные приложения",
    "Мы поговорим о: Feature Modules (Модули функций) Router-Outlet Core Module Shared Module Эти понятия являются фундаментальными для разработки приложений на Angular и помогут вам лучше структурировать ваш код, улучшить производительность и упростить поддержку",
    "1",
    "Feature Modules (Модули функций) Определение Feature Modules — это модули Angular, которые фокусируются на определённой функциональности или области вашего приложения",
    "Они помогают разделить приложение на логические части, делая код более организованным и удобным для поддержки",
    "Зачем нужны Feature Modules Модульность: Разделение приложения на модули улучшает его структуру и делает его более понятным",
    "Ленивая загрузка (Lazy Loading): Позволяет загружать модули по требованию, что уменьшает начальное время загрузки приложения",
    "Командная работа: Упрощает распределение работы между разработчиками",
    "Повторное использование: Модули могут быть переиспользованы в других приложениях",
    "Пример использования Представим, что у нас есть приложение для электронной коммерции с такими разделами: Товары (Products) Корзина (Cart) Профиль пользователя (User Profile) Шаги: ng generate module products --route products --module app.module\nng generate component products/product-list\nng generate component products/product-detail Настройка маршрутизации внутри модуля: const routes: Routes = [\n  { path: '', component: ProductListComponent },\n  { path: ':id', component: ProductDetailComponent },\n]; Ленивая загрузка модуля: const routes: Routes = [\n  { path: 'products', loadChildren: () => import('./products/products.module').then(m => m.ProductsModule) },\n]; 2",
    "Router-Outlet Определение router-outlet — это директива Angular, которая служит контейнером для отображения компонентов, связанных с маршрутами",
    "Она определяет место в шаблоне, куда Angular будет загружать компоненты при навигации",
    "Как это работает Маршрутизация: Когда пользователь переходит по URL, Angular Router сопоставляет этот URL с маршрутом, который указывает, какой компонент следует загрузить",
    "Вставка компонента: Компонент, связанный с маршрутом, загружается и отображается в месте, где находится <router-outlet> ",
    "Пример использования <app-header></app-header>\n<router-outlet></router-outlet>\n<app-footer></app-footer> Настройка маршрутов: const routes: Routes = [\n  { path: '', component: HomeComponent },\n  { path: 'products', loadChildren: () => import('./products/products.module').then(m => m.ProductsModule) },\n]; Главный <router-outlet> в app.component.html определяет место, где будут отображаться компоненты при навигации",
    "Когда пользователь переходит на /products , Angular загружает ProductsModule и отображает соответствующий компонент внутри <router-outlet> ",
    "Вложенные router-outlet Вы можете использовать несколько router-outlet для создания вложенной навигации",
    "<h2>Products</h2>\n<router-outlet></router-outlet> 3",
    "Core Module Определение Core Module — это модуль, который содержит сервисы и другие синглтоны, необходимые всему приложению",
    "Он обычно импортируется только в корневой модуль приложения (AppModule) и нигде более",
    "Зачем нужен Core Module Единая точка доступа: Обеспечивает централизованное место для сервисов, которые должны быть синглтонами",
    "Предотвращение дублирования: Избегает случайного создания нескольких экземпляров сервисов",
    "Организация кода: Улучшает структуру приложения, разделяя глобальные сервисы от функциональных модулей",
    "Что включать в Core Module Сервисы для аутентификации и авторизации Сервисы логирования Глобальные конфигурации Глобальные Guards и Interceptors Пример создания Core Module ng generate module core Пример сервиса аутентификации: @Injectable({\n  providedIn: 'root',\n})\nexport class AuthService {\n  // логика аутентификации\n} Импорт модуля: import { CoreModule } from './core/core.module';\n\n@NgModule({\n  imports: [CoreModule],\n})\nexport class AppModule {} Предотвращение повторного импорта: @NgModule({})\nexport class CoreModule {\n  constructor(@Optional() @SkipSelf() parentModule: CoreModule) {\n    if (parentModule) {\n      throw new Error('CoreModule уже был загружен",
    "Импортируйте его только в AppModule.');\n    }\n  }\n} 4",
    "Shared Module Определение Shared Module — это модуль, который содержит общие компоненты, директивы и пайпы, используемые в разных частях приложения",
    "Зачем нужен Shared Module Повторное использование: Позволяет переиспользовать общие элементы без дублирования кода",
    "Удобство импорта: Можно импортировать один модуль вместо нескольких отдельных компонентов или директив",
    "Организация кода: Помогает поддерживать чистую и понятную структуру проекта",
    "Что включать в Shared Module Общие компоненты: Например, кнопки, модальные окна, элементы формы",
    "Пайпы: Общие преобразователи данных",
    "Директивы: Общие поведения для элементов",
    "Пример создания Shared Module ng generate module shared\nng generate component shared/button\nng generate component shared/modal Конфигурация модуля: @NgModule({\n  declarations: [ButtonComponent, ModalComponent],\n  imports: [CommonModule],\n  exports: [ButtonComponent, ModalComponent, CommonModule],\n})\nexport class SharedModule {} Использование в других модулях: import { SharedModule } from '../shared/shared.module';\n\n@NgModule({\n  imports: [SharedModule],\n})\nexport class ProductsModule {} Заключение Мы рассмотрели четыре ключевые концепции Angular, которые помогают создавать масштабируемые и организованные приложения: Feature Modules позволяют разбивать приложение на логические части, улучшая его структуру и производительность",
    "router-outlet служит точкой вставки компонентов при навигации и является основой маршрутизации в Angular",
    "Core Module используется для размещения глобальных сервисов и синглтонов, необходимых всему приложению",
    "Shared Module содержит общие компоненты, директивы и пайпы, которые могут быть переиспользованы в разных модулях",
    "Используя эти концепции, вы сможете создавать приложения, которые легко поддерживать и масштабировать",
    "Помните, что хорошая структура проекта и организация кода — ключ к успешной разработке",
    "Дополнительные рекомендации: Следуйте принципам SOLID: Это поможет писать более чистый и поддерживаемый код",
    "Изучайте новые возможности Angular: Фреймворк постоянно развивается, и знание новых инструментов поможет вам писать более эффективный код",
    "Практикуйтесь: Лучший способ понять эти концепции — применять их на практике",
    "© 2024 Angular Concepts",
    "Все права защищены."
  ],
  "Architecture.html": [
    "Onion Architecture и Dependency Injection Onion Architecture Структура и принципы Onion Architecture, слои и их взаимодействие",
    "Основная структура Onion Architecture состоит из нескольких слоёв, каждый из которых независим от других",
    "Основная идея заключается в создании ядра приложения, которое не зависит от внешних слоёв",
    "Поток управления В Onion Architecture зависимости направлены внутрь",
    "Это означает, что инфраструктура зависит от ядра, а не наоборот",
    "Основные компоненты и адаптеры В архитектуре используются первичные и вторичные адаптеры, обеспечивающие взаимодействие между ядром приложения и внешними сервисами, такими как БД или API",
    "Полная структура Explicit Architecture Полная структура включает все слои и компоненты, показывая все зависимости и направления потоков данных между слоями",
    "Core Layer (Сердцевина) Core Layer — это основа приложения",
    "Он включает бизнес-логические классы, такие как Domain Entities и Value Objects",
    "Этот слой должен быть полностью независим от других слоёв",
    "Domain Entities и Value Objects Domain Entities представляют основные бизнес-концепции, такие как User или Order",
    "Value Objects используются для определения значений без уникальной идентификации, например, Money или Address",
    "Service Layer (Сервисный слой) Service Layer содержит бизнес-операции, оперирующие над Domain Entities",
    "Здесь обычно реализуется логика, использующая репозитории и взаимодействующая с Core Layer",
    "Infrastructure Layer (Инфраструктурный слой) Infrastructure Layer — это слой, отвечающий за взаимодействие с базами данных, сторонними API и другими внешними системами",
    "В этом слое можно использовать паттерны, такие как Repository для доступа к данным",
    "Presentation Layer (Слой представления) Presentation Layer обеспечивает взаимодействие с пользователем",
    "Этот слой может представлять собой как интерфейсы API, так и пользовательский интерфейс (UI)."
  ],
  "Asynchronous.html": [
    "Асинхронность в C# и ASP.NET Core Документация Введение Теория Примеры Заключение Асинхронность в C# и ASP.NET Core на практике Введение Асинхронность и многопоточность — важные концепции в C# и ASP.NET Core",
    "Правильное понимание этих тем помогает создавать эффективные и масштабируемые приложения, особенно для серверной разработки, где необходимо обрабатывать множество запросов параллельно",
    "Многопоточное программирование Многопоточность позволяет использовать возможности многоядерных процессоров, распределяя задачи между разными потоками",
    "Это особенно полезно для серверных приложений, так как позволяет обрабатывать большое количество клиентских запросов одновременно",
    "Синхронное программирование: Все задачи выполняются последовательно, что блокирует выполнение остальных задач",
    "Асинхронное программирование: Позволяет выполнять задачи параллельно, не блокируя основной поток",
    "Это значительно увеличивает производительность системы",
    "Асинхронные операции Асинхронные операции часто связаны с взаимодействием с внешними устройствами или системами, такими как работа с файлами, сетевые запросы или взаимодействие с базой данных",
    "Во время выполнения таких операций приложение может простаивать, если они выполняются синхронно",
    "Асинхронное программирование позволяет избежать этого, освобождая поток для выполнения других задач",
    "Проблемы с Task.Run и ложная асинхронность Task.Run используется для выполнения задач в фоновом потоке, но это не всегда решение для реальной асинхронности",
    "Он фактически запускает задачу в пуле потоков, а не освобождает основной поток",
    "Это может быть полезно для задач, требующих процессорного времени, но не для задач ввода-вывода",
    "Проблема: Использование Task.Run для задач ввода-вывода создает ненужные потоки, которые просто ожидают завершения операции",
    "Это приводит к избыточным ресурсным затратам и перегрузке пула потоков",
    "Ложная асинхронность: Когда мы запускаем задачу в потоке, она не становится истинно асинхронной, так как мы всё равно ждем завершения задачи",
    "Например, для долгосрочных операций это не освобождает основной поток, а просто использует другой поток для выполнения операции",
    "Истинная асинхронность заключается в использовании async/await и Task , где основной поток освобождается и возвращается обратно к коду, только когда операция завершается",
    "Проблемы синхронного программирования Синхронное программирование может приводить к блокировке потоков при выполнении долгих операций, таких как запросы к базе данных или взаимодействие с внешними API",
    "Это замедляет работу приложения и увеличивает время отклика",
    "Теория асинхронного программирования Асинхронное программирование решает проблему блокировки потоков",
    "Вместо того чтобы ждать завершения задачи, поток может переключаться на выполнение других операций, пока не придет ответ",
    "Это позволяет значительно сократить общее время выполнения программы и повысить ее производительность",
    "Преимущества асинхронности Асинхронное программирование позволяет повысить производительность приложений, особенно в многопользовательских системах",
    "Потоки могут переключаться между задачами, не дожидаясь завершения текущей операции",
    "Это особенно полезно для серверных приложений с большим количеством одновременных запросов",
    "Пример асинхронного выполнения задач Рассмотрим пример API, который обрабатывает несколько запросов одновременно",
    "Например, клиент отправляет запрос на получение информации о пользователе, и API выполняет несколько операций: получение пользователя, его любимой игры и его локации",
    "Эти задачи можно выполнять асинхронно, что сокращает общее время выполнения запроса",
    "public async Task<UserInfo> GetUserInfoAsync(int userId)\n{\n    var userTask = GetUserAsync(userId);\n    var gameTask = GetFavoriteGameAsync(userId);\n    var locationTask = GetLocationAsync(userId);\n\n    await Task.WhenAll(userTask, gameTask, locationTask);\n\n    return new UserInfo\n    {\n        User = userTask.Result,\n        FavoriteGame = gameTask.Result,\n        Location = locationTask.Result\n    };\n} В этом примере три задачи (получение пользователя, его игры и локации) выполняются параллельно, что позволяет сократить время обработки запроса",
    "Асинхронные методы и задачи Асинхронные методы возвращают объект Task , который представляет собой задачу, выполняемую в фоновом режиме",
    "Поток может продолжать выполнение других операций, пока задача не завершится",
    "Ключевые слова async и await позволяют легко работать с асинхронными методами, не блокируя поток",
    "Выполнение задач в фоновом потоке Асинхронные задачи выполняются в фоновом потоке, позволяя основному потоку продолжать выполнение других задач",
    "Например, метод Task.Run() позволяет запускать задачу в фоновом режиме, при этом основной поток может продолжать работу",
    "Ожидание выполнения задачи Когда задача выполняется асинхронно, мы можем использовать ключевое слово await , чтобы дождаться её завершения",
    "Это позволяет сделать код более читабельным и избавиться от сложных обратных вызовов (callback)",
    "Вместо блокировки основного потока, он освобождается для выполнения других операций",
    "Демонстрация асинхронности Асинхронные задачи позволяют обрабатывать запросы параллельно, не блокируя основной поток",
    "Например, можно запустить несколько операций одновременно и дождаться их завершения с помощью Task.WhenAll() ",
    "Оптимизация кода с использованием асинхронности Асинхронное программирование помогает оптимизировать код, позволяя выполнять несколько задач одновременно",
    "В результате снижается время выполнения программы и улучшается производительность приложения",
    "Заключение Использование async и await в C# позволяет значительно повысить производительность серверных приложений",
    "Асинхронное программирование освобождает потоки для выполнения других операций, что особенно важно при обработке большого количества запросов",
    "Грамотное использование асинхронности предотвращает блокировки потоков и позволяет масштабировать приложение",
    "2023 Асинхронность в C# и ASP.NET Core"
  ],
  "EF_Core.html": [
    "Обзор Entity Framework Обзор Entity Framework Обзор Entity Framework 1",
    "Обзор Entity Framework Entity Framework (EF) — это ORM (Object-Relational Mapping) для .NET, который позволяет разработчикам работать с базой данных через объекты .NET вместо написания SQL-запросов напрямую",
    "Абстракция от деталей базы данных",
    "Удобный API для работы с данными",
    "Поддержка различных СУБД (SQL Server, MySQL, PostgreSQL и др.)",
    "2",
    "Архитектура и принципы работы Entity Framework построен вокруг следующих компонентов: DbContext: Основной класс для взаимодействия с базой данных, управляет соединениями, объектами и транзакциями",
    "DbSet : DbSet<TEntity>: Представляет коллекцию объектов определенного типа, соответствующих таблице базы данных",
    "Модель данных: Определяет, как классы .NET сопоставляются с таблицами в базе данных",
    "Основные принципы EF включают конвенции и конфигурации (через атрибуты или Fluent API) для работы с моделями и таблицами",
    "3",
    "Режимы работы Code First: Модели создаются в коде, EF генерирует базу данных",
    "Поддерживает миграции для управления схемой базы данных",
    "Database First: Используется существующая база данных, на основе которой генерируются модели",
    "Model First: Модели создаются в графическом интерфейсе, затем генерируются базы данных и классы",
    "4",
    "Контекст данных (DbContext) и DbSet DbContext управляет соединением с базой данных и транзакциями: public class MyDbContext : DbContext\n    {\n        public DbSet<User> Users { get; set; }\n        public DbSet<Order> Orders { get; set; }\n    \n        protected override void OnModelCreating(ModelBuilder modelBuilder)\n        {\n            // Конфигурации моделей\n        }\n    } DbSet представляет таблицу в базе данных",
    "Операции с данными включают добавление, удаление и обновление",
    "5",
    "Миграции и управление схемой базы данных Миграции позволяют управлять изменениями схемы базы данных на протяжении разработки: Создание миграции: Add-Migration MigrationName Применение миграций: Update-Database Откат миграции: Remove-Migration 6",
    "Отслеживание изменений и жизненный цикл объектов EF отслеживает состояния объектов (Added, Modified, Unchanged, Deleted, Detached)",
    "Вы можете использовать AsNoTracking() для отключения отслеживания, чтобы повысить производительность при чтении данных",
    "7",
    "Загрузка данных Eager Loading: Загрузка связанных данных сразу с основным объектом с помощью Include() ",
    "Lazy Loading: Отложенная загрузка данных по запросу",
    "Настраивается через виртуальные свойства",
    "Explicit Loading: Явная загрузка данных через методы Entry() , Collection() или Reference() ",
    "8",
    "Работа с отношениями EF поддерживает отношения One-to-One, One-to-Many, Many-to-Many",
    "Настройки могут быть сделаны через Fluent API или атрибуты данных",
    "modelBuilder.Entity<User>()\n        .HasMany(u => u.Orders)\n        .WithOne(o => o.User); 9",
    "LINQ to Entities и запросы LINQ to Entities позволяет строить запросы к базе данных через C#: var users = context.Users.Where(u => u.Age > 18).ToList(); 10",
    "Транзакции и конкуренция Транзакции помогают гарантировать согласованность данных",
    "EF поддерживает как неявные транзакции при вызове SaveChanges() , так и явные транзакции для более сложных сценариев",
    "using var transaction = context.Database.BeginTransaction();\n    try\n    {\n        context.SaveChanges();\n        transaction.Commit();\n    }\n    catch\n    {\n        transaction.Rollback();\n        throw;\n    } 11",
    "Производительность и оптимизация EF позволяет оптимизировать работу с данными через отключение отслеживания ( AsNoTracking() ), пакетную обработку, использование кэширования и профилирование запросов",
    "12",
    "Расширяемость и пользовательские конфигурации Fluent API и атрибуты данных позволяют гибко настраивать модели и конфигурации сущностей в EF",
    "modelBuilder.Entity<User>()\n        .HasIndex(u => u.Email)\n        .IsUnique(); 13",
    "Часто задаваемые вопросы на собеседованиях Что такое Entity Framework и как он работает? Объясните разницу между Code First и Database First",
    "Как работает отслеживание изменений в EF? Что такое Lazy Loading и как его отключить? 14",
    "Практические советы Профилируйте запросы с помощью SQL-профилировщиков",
    "Используйте Include() осторожно, чтобы не создавать избыточные запросы",
    "Управляйте жизненным циклом DbContext для лучшей производительности",
    "2023 Обзор Entity Framework"
  ],
  "index.html": [
    "Документация по проекту Документация Введите поисковый запрос: Документация проекта Добро пожаловать в документацию, собранную для вашего проекта",
    "Выберите тему, чтобы узнать больше",
    "SQL Guide Основные команды SQL для создания и управления базами данных",
    "Angular Guide Основные концепции Angular, включая модули и маршрутизацию",
    "Asynchronous programming Руководство по асинхронности в C# и ASP.NET Core",
    "Entity Framework Core Обзор Entity Framework Core для работы с базами данных",
    "Data Types: Value and Reference Сравнение значимых и ссылочных типов в C#",
    "Logger Guide Подробное руководство по конфигурации Serilog и созданию логов",
    "Middleware Guide Описание Middleware в ASP.NET Core и создание кастомных компонентов",
    "Architecture Guide Описание Архитектур в .NET"
  ],
  "Logger.html": [
    "Serilog Guide Serilog Guide Введение Конфигурация Sinks Использование Руководство по Serilog Подробное описание конфигурации и использования Serilog в .NET Введение Serilog — это библиотека журналирования для .NET, обеспечивающая структурированное логирование",
    "Она позволяет записывать логи в различных форматах и отправлять их в различные хранилища (Sinks)",
    "Конфигурация Serilog Конфигурация Serilog может быть выполнена программно или с помощью конфигурационных файлов",
    "Вот пример программной конфигурации: // Установка глобального логгера\nLog.Logger = new LoggerConfiguration()\n    .MinimumLevel.Debug()\n    .WriteTo.Console()\n    .WriteTo.File(\"logs/myapp.txt\", rollingInterval: RollingInterval.Day)\n    .CreateLogger();\n\n// Использование логгера\nLog.Information(\"Приложение запущено\");\nLog.CloseAndFlush(); В этом примере мы настроили Serilog для вывода логов в консоль и файл с ежедневным разделением (rolling)",
    "Sinks в Serilog Sinks — это конечные точки, куда Serilog отправляет логи",
    "Существует множество встроенных и сторонних Sink, некоторые из них: Console : вывод логов в консоль",
    "File : запись логов в файл",
    "Seq : отправка логов в Seq сервер для структурированного просмотра",
    "Elasticsearch : отправка логов в Elasticsearch для индексирования и поиска",
    "MSSqlServer : запись логов в базу данных SQL Server",
    "RollingFile : создание файлов логов с разделением по дате или размеру",
    "Email : отправка логов по электронной почте",
    "Чтобы использовать Sink, необходимо установить соответствующий пакет NuGet и добавить его в конфигурацию Serilog",
    "Использование Serilog в приложении Serilog интегрируется с .NET приложениями различными способами",
    "Рассмотрим пример использования в ASP.NET Core приложении: // В Program.cs\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        Log.Logger = new LoggerConfiguration()\n            .WriteTo.Console()\n            .WriteTo.File(\"logs/webapp.txt\", rollingInterval: RollingInterval.Day)\n            .CreateLogger();\n\n        try\n        {\n            Log.Information(\"Запуск веб-приложения\");\n            CreateHostBuilder(args).Build().Run();\n        }\n        catch (Exception ex)\n        {\n            Log.Fatal(ex, \"Приложение завершилось с ошибкой\");\n        }\n        finally\n        {\n            Log.CloseAndFlush();\n        }\n    }\n\n    public static IHostBuilder CreateHostBuilder(string[] args) =>\n        Host.CreateDefaultBuilder(args)\n            .UseSerilog() // Добавляем Serilog\n            .ConfigureWebHostDefaults(webBuilder =>\n            {\n                webBuilder.UseStartup ();\n            });\n} В этом примере мы настроили Serilog и заменили встроенный логгер ASP.NET Core на Serilog с помощью метода UseSerilog() ",
    "Оптимизация логирования с LoggerMessage Для повышения производительности логирования можно использовать статические частичные классы и методы с атрибутом [LoggerMessage] ",
    "Вот пример: public static partial class LogMessages\n{\n    private static readonly Action<ILogger, Exception> FailedToProcessWorkItem = LoggerMessage.Define(\n        LogLevel.Critical,\n        new EventId(13, nameof(FailedToProcessWorkItem)),\n        \"Epic failure processing item!\");\n\n    [LoggerMessage(\n        EventId = 0,\n        Level = LogLevel.Information,\n        Message = \"Hello World! Logging is {Description}.\")]\n    public static partial void LogStartupMessage(this ILogger logger, string description);\n} В этом примере мы определяем статические методы для логирования с предопределёнными сообщениями и уровнями логирования",
    "Это помогает избежать лишних аллокаций и повышает производительность",
    "Высокопроизводительное логирование в .NET В .NET для повышения производительности логирования рекомендуется минимизировать объём создаваемых объектов и избегать аллокаций в критичных местах",
    "Использование LoggerMessage позволяет предварительно подготовить шаблоны сообщений, что снижает накладные расходы на их создание во время выполнения",
    "Пример 1: Использование LoggerMessage.Define Метод LoggerMessage.Define позволяет создать шаблон лог-сообщения с параметрами, которые будут подставлены при вызове логирования",
    "Это помогает избежать аллокаций строк при каждом вызове логирования",
    "private static readonly Action<ILogger, int, string, Exception> UserLoginAttempt =\n        LoggerMessage.Define<int, string>(\n            LogLevel.Information,\n            new EventId(101, nameof(UserLoginAttempt)),\n            \"User {UserId} attempted login with status {Status}\");\n    \n    public static void LogUserLoginAttempt(ILogger logger, int userId, string status)\n    {\n        UserLoginAttempt(logger, userId, status, null);\n    }\n    \n    // Использование:\n    LogUserLoginAttempt(logger, 42, \"Success\"); В этом примере мы создаем метод LogUserLoginAttempt , который подготавливает сообщение для логирования, включая параметры UserId и Status , не создавая строку каждый раз заново",
    "Пример 2: Использование частичных методов с LoggerMessage Частичные методы позволяют определять лог-сообщения с предопределёнными уровнями логирования и форматами сообщений",
    "Это упрощает вызов логирования и снижает затраты на выполнение",
    "public static partial class LogMessages\n    {\n        [LoggerMessage(\n            EventId = 102,\n            Level = LogLevel.Warning,\n            Message = \"Failed attempt to access resource {ResourceName} by user {UserId}\")]\n        public static partial void LogAccessAttempt(this ILogger logger, string resourceName, int userId);\n    }\n    \n    // Использование:\n    logger.LogAccessAttempt(\"RestrictedArea\", 42); Здесь используется частичный метод LogAccessAttempt , который добавляет предопределённое сообщение и параметры, такие как ResourceName и UserId ",
    "Это помогает избежать затрат на форматирование строки при каждом вызове",
    "Пример 3: Логирование с динамическими параметрами В сложных сценариях можно использовать LoggerMessage.Define с несколькими параметрами для логирования детализированных сообщений",
    "private static readonly Action<ILogger, string, int, string, Exception> ProcessItemError =\n        LoggerMessage.Define<string, int, string>(\n            LogLevel.Error,\n            new EventId(103, nameof(ProcessItemError)),\n            \"Error processing item {ItemId} for user {UserId} with status {Status}\");\n    \n    public static void LogProcessItemError(ILogger logger, string itemId, int userId, string status)\n    {\n        ProcessItemError(logger, itemId, userId, status, null);\n    }\n    \n    // Использование:\n    LogProcessItemError(logger, \"Item42\", 7, \"Failed\"); Этот подход позволяет логировать ошибки с динамическими параметрами, такими как ItemId , UserId и Status , используя заранее подготовленный шаблон для повышения производительности",
    "Рекомендация CA1848: Использование шаблонов с LoggerMessage Рекомендация CA1848 из анализа кода .NET рекомендует использовать LoggerMessage для логирования, чтобы улучшить производительность, избегая лишних аллокаций",
    "Это особенно актуально для частого логирования, где создание строковых сообщений вручную может приводить к значительным затратам памяти и процессорного времени",
    "Следование CA1848 помогает оптимизировать логирование и сделать код более эффективным в высоконагруженных приложениях",
    "Метод LoggerMessage.Define Метод LoggerMessage.Define используется для создания шаблонов сообщений с предопределёнными уровнями логирования и параметрами",
    "Он позволяет определить сообщение, которое затем можно вызывать с нужными параметрами, минимизируя накладные расходы на создание строки",
    "private static readonly Action<ILogger, int, string, Exception> UserLoggedIn =\n        LoggerMessage.Define<int, string>(\n            LogLevel.Information,\n            new EventId(1, nameof(UserLoggedIn)),\n            \"User {UserId} logged in with role {UserRole}\");\n            \n    // Использование\n    UserLoggedIn(logger, userId, userRole, null); Этот подход особенно полезен для многократно повторяющихся сообщений и позволяет сделать логирование более структурированным и эффективным",
    "Логирование в .NET В .NET платформа логирования основана на Microsoft.Extensions.Logging и предоставляет единый интерфейс для всех логов",
    "Это позволяет использовать различные реализации логирования (например, Serilog или Log4Net ) без изменения бизнес-логики приложения",
    "При разработке высоконагруженных приложений рекомендуется использовать LoggerMessage для оптимизации производительности и структурирования сообщений, что также облегчает последующий анализ данных."
  ],
  "SQl.html": [
    "SQL Guide by Fang Ying, Sham SQL Оптимизация SQL-запросов и индексация Индексы играют ключевую роль в повышении производительности SQL-запросов, позволяя ускорить доступ к данным",
    "Index Seek и Index Scan Index Seek используется для быстрого поиска данных, используя ключевые индексы, в то время как Index Scan выполняет полное сканирование индекса",
    "Key Lookup Key Lookup выполняется, когда данные не могут быть найдены только по индексу",
    "Это может замедлить выполнение запроса, особенно если записи многократно повторяются",
    "Логический поиск и плотность данных Логический поиск по индексу эффективен при плотности данных до 30%",
    "Использование статистики запросов и параметра Estimate Cost позволяет оценить стоимость запроса",
    "Предотвращение SQL-инъекций SQL-инъекции представляют серьёзную угрозу",
    "Использование параметризованных запросов и надёжных методов фильтрации предотвращает инъекции",
    "1",
    "Язык структурированных запросов (SQL) Обзор команд SQL для создания баз данных, работы с таблицами и обработки данных",
    "-- Создать новую базу данных\n                CREATE DATABASE sample2;\n                \n                -- Использовать базу данных\n                USE sample2;\n                \n                -- Создать таблицу customer\n                CREATE TABLE customer (\n                    customerid INT IDENTITY(1,1) PRIMARY KEY,\n                    customernumber INT NOT NULL UNIQUE CHECK (customernumber > 0),\n                    lastname VARCHAR(30) NOT NULL,\n                    firstname VARCHAR(30) NOT NULL,\n                    areacode INT DEFAULT 71000,\n                    address VARCHAR(50),\n                    country VARCHAR(50) DEFAULT 'Malaysia'\n                ); 2",
    "Вставка и отображение данных Добавление записей, извлечение данных и просмотр конкретных столбцов или условий",
    "-- Вставить значения в таблицу customer\n                INSERT INTO customer VALUES\n                    (100, 'Fang Ying', 'Sham', '418999', 'Address Example', DEFAULT),\n                    (200, 'Mei Mei', 'Tan', DEFAULT, 'Another Address', 'Thailand'),\n                    (300, 'Albert', 'John', DEFAULT, 'Some Address', DEFAULT);\n                \n                -- Показать все записи из таблицы customer\n                SELECT * FROM customer;\n                \n                -- Показать конкретные столбцы\n                SELECT customerid, customernumber, lastname, firstname FROM customer; 3",
    "Изменение структуры таблицы Изменение структуры таблицы путем добавления, обновления или удаления столбцов",
    "-- Добавить новый столбец в таблицу customer\n                ALTER TABLE customer\n                ADD phonenumber VARCHAR(20);\n                \n                -- Обновить данные в новом столбце\n                UPDATE customer SET phonenumber = '1234545346' WHERE customerid = 1;\n                UPDATE customer SET phonenumber = '45554654' WHERE customerid = 2;\n                \n                -- Удалить столбец phonenumber из таблицы\n                ALTER TABLE customer\n                DROP COLUMN phonenumber; 4",
    "Удаление записей и таблиц Команды для удаления конкретных записей или целых таблиц из базы данных",
    "-- Удалить конкретную запись из таблицы customer\n                DELETE FROM customer\n                WHERE country = 'Thailand';\n                \n                -- Удалить всю таблицу customer\n                DROP TABLE customer; 5",
    "Изменение типов данных Изменение типов данных столбцов и использование временных преобразований типов данных",
    "-- Изменить тип данных существующего столбца\n                ALTER TABLE customer\n                ALTER COLUMN phonenumber VARCHAR(10);\n                \n                -- Примеры CAST и CONVERT для временного изменения типа данных\n                SELECT CAST('2017-08-25 00:00:00.000' AS DATE);\n                SELECT CONVERT(DATE, '2017-08-25 00:00:00.000'); 6",
    "Извлечение и фильтрация данных Использование фильтров и сортировки для извлечения определенных наборов данных",
    "-- Показать первые две записи из таблицы customer\n                SELECT TOP 2 * FROM customer;\n                \n                -- Извлечение конкретных столбцов с сортировкой\n                SELECT customerfirstname, customerlastname\n                FROM customer\n                ORDER BY customerlastname DESC;\n                \n                -- Использование LIKE для поиска по шаблону\n                SELECT * FROM customer\n                WHERE customerlastname LIKE '_r%';\n                \n                -- Использование IN для фильтрации по нескольким значениям\n                SELECT * FROM customer\n                WHERE customerlastname IN ('Brown', 'Michael', 'Jim'); 7",
    "Агрегатные функции Использование агрегатных функций, таких как COUNT, SUM и AVG для суммарной обработки данных",
    "-- Подсчет записей, соответствующих определенному условию\n                SELECT COUNT(*) AS [Number of Records]\n                FROM customer\n                WHERE customerfirstname LIKE 'B%';\n                \n                -- Суммирование значений в определенных столбцах\n                SELECT sale.employeeid, EmployeeFirstName, EmployeeLastName, \n                       COUNT(*) AS [Number of Orders],\n                       SUM(salequantity) AS [Total Quantity]\n                FROM sale\n                JOIN employee ON sale.employeeid = employee.employeeid\n                GROUP BY sale.employeeid, EmployeeFirstName, EmployeeLastName; 8",
    "Функции работы с датами и временем Использование SQL-функций для работы с датами и временем",
    "-- Подсчет записей по месяцам с суммированием сумм\n                SELECT MONTH(saledate) AS [Month],\n                       COUNT(*) AS [Number of Sales],\n                       SUM(salequantity * saleunitprice) AS [Total Amount]\n                FROM sale\n                GROUP BY MONTH(saledate);\n                \n                -- Поиск максимальных и минимальных значений\n                SELECT MAX(Salary) FROM EmployeeSalary;\n                SELECT MIN(Salary) FROM EmployeeSalary;\n                \n                -- Вычисление средних значений\n                SELECT AVG(Salary) FROM EmployeeSalary; 9",
    "Группировка и фильтрация групп с помощью HAVING Использование GROUP BY и HAVING для группировки данных и фильтрации агрегированных результатов",
    "-- Подсчет должностей с количеством больше одного\n                SELECT JobTitle, COUNT(JobTitle) AS [Job Count]\n                FROM EmployeeDemographics ED\n                JOIN EmployeeSalary ES ON ED.EmployeeID = ES.EmployeeID\n                GROUP BY JobTitle\n                HAVING COUNT(JobTitle) > 1;\n                \n                -- Фильтрация средней зарплаты для должностей с определенным значением\n                SELECT JobTitle, AVG(Salary) AS [Average Salary]\n                FROM EmployeeDemographics ED\n                JOIN EmployeeSalary ES ON ED.EmployeeID = ES.EmployeeID\n                GROUP BY JobTitle\n                HAVING AVG(Salary) > 45000\n                ORDER BY [Average Salary]; 10",
    "Временное преобразование типов данных Использование временного преобразования типов данных с помощью функций CAST и CONVERT",
    "-- Использование CAST для преобразования типа данных\n                SELECT CAST('2017-08-25 00:00:00.000' AS DATE);\n                \n                -- Использование CONVERT со стилем для преобразования типа данных\n                SELECT CONVERT(DATE, '2017-08-25 00:00:00.000'); 11",
    "Условная логика с CASE Использование оператора CASE для условных выражений в SQL-запросах",
    "-- Использование CASE для классификации данных по условиям\n                SELECT FirstName, LastName, Age,\n                       CASE\n                           WHEN Age > 30 THEN 'Old'\n                           WHEN Age BETWEEN 27 AND 30 THEN 'Young'\n                           ELSE 'Baby'\n                       END AS AgeCategory\n                FROM EmployeeDemographics\n                WHERE Age IS NOT NULL\n                ORDER BY Age;\n                \n                -- Применение CASE с арифметическими операциями\n                SELECT FirstName, LastName, JobTitle, Salary,\n                       CASE\n                           WHEN JobTitle = 'Salesman' THEN Salary + (Salary * 0.10)\n                           WHEN JobTitle = 'Accountant' THEN Salary + (Salary * 0.05)\n                           WHEN JobTitle = 'HR' THEN Salary + (Salary * 0.000001)\n                           ELSE Salary + (Salary * 0.03)\n                       END AS SalaryAfterRaise\n                FROM EmployeeDemographics ED\n                JOIN EmployeeSalary ES ON ED.EmployeeID = ES.EmployeeID; 12",
    "Разделение данных Разделение данных для нумерации строк, ранжирования или других вычислений в определенных группах",
    "-- Использование PARTITION BY для подсчета пола в подмножестве\n                SELECT FirstName, LastName, Gender, Salary,\n                       COUNT(Gender) OVER (PARTITION BY Gender) AS TotalGender\n                FROM EmployeeDemographics ED\n                JOIN EmployeeSalary ES ON ED.EmployeeID = ES.EmployeeID;\n                \n                -- Пример с ROW_NUMBER() для присвоения уникальных рангов внутри каждой группы\n                SELECT *, ROW_NUMBER() OVER(PARTITION BY JobTitle ORDER BY Salary DESC) AS SalaryRank\n                FROM EmployeeSalary\n                ORDER BY JobTitle, SalaryRank; 13",
    "Подзапросы Использование подзапросов в SELECT, WHERE и FROM для извлечения или фильтрации данных",
    "-- Подзапрос в SELECT для расчета средней зарплаты\n                SELECT EmployeeID, Salary,\n                       (SELECT AVG(Salary) FROM EmployeeSalary) AS AllAvgSalary\n                FROM EmployeeSalary;\n                \n                -- Подзапрос в WHERE для фильтрации по конкретным критериям\n                SELECT EmployeeID, JobTitle, Salary\n                FROM EmployeeSalary\n                WHERE Salary IN (SELECT MAX(Salary) FROM EmployeeSalary); 14",
    "Самосоединения (Self Joins) Выполнение самосоединений для создания иерархических связей внутри одной таблицы",
    "-- Самосоединение для отображения сотрудников и их менеджеров\n        SELECT E.employeeID, E.employeefirstname + ' ' + E.employeelastname AS [Полное Имя],\n               M.employeefirstname + ' ' + M.employeelastname AS [Имя Менеджера]\n        FROM staff E\n        INNER JOIN staff M ON E.managerID = M.employeeID;\n        \n        -- Левое внешнее соединение для отображения всех сотрудников с их менеджерами\n        SELECT E.employeeID, E.employeefirstname + ' ' + E.employeelastname AS [Полное Имя],\n               M.employeefirstname + ' ' + M.employeelastname AS [Имя Менеджера]\n        FROM staff E\n        LEFT JOIN staff M ON E.managerID = M.employeeID; 15",
    "Объединения SQL (Unions) Использование UNION, UNION ALL, INTERSECT и EXCEPT для объединения или фильтрации нескольких наборов данных",
    "-- UNION объединяет результаты и удаляет дубликаты\n        SELECT cust_lname, cust_fname FROM customer\n        UNION\n        SELECT cust_lname, cust_fname FROM customer_2;\n        \n        -- UNION ALL объединяет результаты и сохраняет все дубликаты\n        SELECT cust_lname, cust_fname FROM customer\n        UNION ALL\n        SELECT cust_lname, cust_fname FROM customer_2;\n        \n        -- INTERSECT показывает только строки, общие для обоих наборов данных\n        SELECT cust_lname, cust_fname FROM customer\n        INTERSECT\n        SELECT cust_lname, cust_fname FROM customer_2;\n        \n        -- EXCEPT показывает только строки, уникальные для первого набора данных\n        SELECT cust_lname, cust_fname FROM customer\n        EXCEPT\n        SELECT cust_lname, cust_fname FROM customer_2; 16",
    "Представления и временные таблицы Создание представлений и временных таблиц для упрощения сложных запросов и управления временными данными",
    "-- Создать представление для отображения информации о клиентах и данных о продажах\n        CREATE VIEW CustomerView AS\n        SELECT customerfirstname + ' ' + customerlastname AS [Имя Клиента],\n               customerphonenumber, inventoryname, saledate, salequantity, saleunitprice\n        FROM customer\n        INNER JOIN sale ON customer.customerid = sale.customerid\n        INNER JOIN inventory ON sale.inventoryid = inventory.inventoryid;\n        \n        -- Создание временной таблицы для временного хранения данных\n        CREATE TABLE #temp_Employee (\n            JobTitle VARCHAR(100),\n            EmployeesPerJob INT,\n            AvgAge INT,\n            AvgSalary INT\n        );\n        \n        -- Вставка данных во временную таблицу\n        INSERT INTO #temp_Employee\n        SELECT JobTitle, COUNT(JobTitle), AVG(Age), AVG(Salary)\n        FROM EmployeeDemographics emp\n        JOIN EmployeeSalary sal ON emp.EmployeeID = sal.EmployeeID\n        GROUP BY JobTitle; 17",
    "Общие табличные выражения (CTE) Использование CTE для временных наборов данных, упрощающих сложные подзапросы",
    "-- Определение CTE для разделения данных по полу и вычисления общего количества для каждой группы\n        WITH CTE_Employee AS (\n            SELECT FirstName, LastName, Gender, Salary,\n                   COUNT(Gender) OVER (PARTITION BY Gender) AS TotalGender\n            FROM EmployeeDemographics ED\n            JOIN EmployeeSalary ES ON ED.EmployeeID = ES.EmployeeID\n            WHERE Salary > '45000'\n        )\n        SELECT FirstName, LastName, Gender, TotalGender\n        FROM CTE_Employee\n        WHERE TotalGender = (SELECT MIN(TotalGender) FROM CTE_Employee); 18",
    "Дублирование и резервное копирование данных Копирование данных таблицы для создания резервных копий или дублирования структур с данными",
    "-- Дублирование записей клиентов с данными о продажах и запасах в новой таблице\n        SELECT customerfirstname + ' ' + customerlastname AS [Имя Клиента],\n               customerphonenumber, inventoryname, saledate, salequantity, saleunitprice\n        INTO customerRec\n        FROM customer\n        INNER JOIN sale ON customer.customerid = sale.customerid\n        INNER JOIN inventory ON sale.inventoryid = inventory.inventoryid\n        ORDER BY customerfirstname + ' ' + customerlastname, inventoryname; 19",
    "Функции ранжирования SQL Использование функций ранжирования, таких как ROW_NUMBER, RANK и DENSE_RANK, для присвоения рангов строкам данных",
    "-- Использование ROW_NUMBER для получения уникального последовательного номера для каждой строки на основе зарплаты\n        SELECT *,\n               ROW_NUMBER() OVER (ORDER BY Salary DESC) AS SalaryRank\n        FROM EmployeeSalary;\n        \n        -- Использование RANK для присвоения рангов с возможными пропусками, если значения совпадают\n        SELECT *, \n               RANK() OVER (ORDER BY Salary DESC) AS SalaryRank\n        FROM EmployeeSalary;\n        \n        -- Использование DENSE_RANK для присвоения рангов без пропусков\n        SELECT *, \n               DENSE_RANK() OVER (ORDER BY Salary DESC) AS SalaryRank\n        FROM EmployeeSalary; 20",
    "Функция NTILE Использование NTILE для разделения результирующего набора на заданное количество групп и присвоения группе ранга",
    "-- Использование NTILE для разделения сотрудников на три группы на основе их зарплаты\n        SELECT *, \n               NTILE(3) OVER (ORDER BY Salary DESC) AS SalaryGroup\n        FROM EmployeeSalary;\n        \n        -- Разделение по должности для получения групп NTILE в каждой категории должностей\n        SELECT *, \n               NTILE(3) OVER (PARTITION BY JobTitle ORDER BY Salary DESC) AS SalaryGroup\n        FROM EmployeeSalary\n        ORDER BY JobTitle, SalaryGroup; 21",
    "Объединение данных с помощью соединений (Joins) Использование различных типов соединений для объединения данных из нескольких таблиц на основе отношений",
    "-- Внутреннее соединение для получения только совпадающих записей из обеих таблиц\n        SELECT * \n        FROM inventory\n        INNER JOIN sale ON sale.inventoryid = inventory.inventoryid;\n        \n        -- Полное внешнее соединение для получения всех записей из обеих таблиц\n        SELECT sale.inventoryid, inventoryname \n        FROM inventory\n        FULL OUTER JOIN sale ON sale.inventoryid = inventory.inventoryid\n        WHERE sale.inventoryid IS NULL;\n        \n        -- Левое соединение для получения всех записей из левой таблицы с совпадающими записями из правой\n        SELECT inventory.inventoryid, inventoryname\n        FROM inventory\n        LEFT JOIN sale ON sale.inventoryid = inventory.inventoryid\n        WHERE sale.inventoryid IS NULL;\n        \n        -- Правое соединение для получения всех записей из правой таблицы с совпадающими записями из левой\n        SELECT sale.inventoryid, inventoryname\n        FROM inventory\n        RIGHT JOIN sale ON sale.inventoryid = inventory.inventoryid; 22",
    "Оператор CASE Использование оператора CASE для условной логики в SQL-запросах",
    "-- Использование CASE для классификации сотрудников по возрасту\n        SELECT FirstName, LastName, Age,\n               CASE\n                   WHEN Age > 30 THEN 'Old'\n                   WHEN Age BETWEEN 27 AND 30 THEN 'Young'\n                   ELSE 'Baby'\n               END AS AgeCategory\n        FROM EmployeeDemographics\n        WHERE Age IS NOT NULL\n        ORDER BY Age;\n        \n        -- Применение CASE для расчета скорректированных зарплат в зависимости от должности\n        SELECT FirstName, LastName, JobTitle, Salary,\n               CASE\n                   WHEN JobTitle = 'Salesman' THEN Salary + (Salary * 0.10)\n                   WHEN JobTitle = 'Accountant' THEN Salary + (Salary * 0.05)\n                   WHEN JobTitle = 'HR' THEN Salary + (Salary * 0.000001)\n                   ELSE Salary + (Salary * 0.03)\n               END AS SalaryAfterRaise\n        FROM EmployeeDemographics ED\n        JOIN EmployeeSalary ES ON ED.EmployeeID = ES.EmployeeID; 23",
    "Строковые функции Использование строковых функций SQL, таких как TRIM, REPLACE и SUBSTRING для обработки текста",
    "-- Удаление пробелов с помощью TRIM, LTRIM и RTRIM\n        SELECT EmployeeID, TRIM(EmployeeID) AS IDTRIM FROM EmployeeErrors;\n        SELECT EmployeeID, LTRIM(EmployeeID) AS IDLTRIM FROM EmployeeErrors;\n        SELECT EmployeeID, RTRIM(EmployeeID) AS IDRTRIM FROM EmployeeErrors;\n        \n        -- Замена определенного текста в строке\n        SELECT LastName, REPLACE(LastName, '- Fired', '') AS LastNameFixed FROM EmployeeErrors;\n        \n        -- Извлечение подстрок с помощью SUBSTRING\n        SELECT SUBSTRING(FirstName, 1, 3) AS FirstNameShort FROM EmployeeErrors; 24",
    "Хранимые процедуры Создание хранимых процедур для автоматизации повторяющихся задач или инкапсуляции логики",
    "-- Создание хранимой процедуры для возврата данных сотрудников на основе должности\n        CREATE PROCEDURE Temp_Employee @JobTitle NVARCHAR(100)\n        AS\n        BEGIN\n            DROP TABLE IF EXISTS #temp_employee;\n            CREATE TABLE #temp_employee (\n                JobTitle VARCHAR(100),\n                EmployeesPerJob INT,\n                AvgAge INT,\n                AvgSalary INT\n            );\n        \n            INSERT INTO #temp_employee\n            SELECT JobTitle, COUNT(JobTitle), AVG(Age), AVG(Salary)\n            FROM EmployeeDemographics emp\n            JOIN EmployeeSalary sal ON emp.EmployeeID = sal.EmployeeID\n            WHERE JobTitle = @JobTitle\n            GROUP BY JobTitle;\n        \n            SELECT * FROM #temp_employee;\n        END;\n        -- Выполнение хранимой процедуры с параметром\n        EXEC Temp_Employee @JobTitle = 'Salesman'; 25",
    "Подзапросы Использование подзапросов в SELECT, FROM и WHERE для вложенных запросов",
    "-- Подзапрос в SELECT для получения средней зарплаты наряду с индивидуальными зарплатами\n        SELECT EmployeeID, Salary, \n               (SELECT AVG(Salary) FROM EmployeeSalary) AS AllAvgSalary\n        FROM EmployeeSalary;\n        \n        -- Подзапрос в WHERE для фильтрации записей\n        SELECT EmployeeID, JobTitle, Salary\n        FROM EmployeeSalary\n        WHERE Salary IN (SELECT MAX(Salary) FROM EmployeeSalary);\n        \n        -- Подзапрос в FROM для создания псевдонима таблицы с вычисленными данными\n        SELECT a.EmployeeID, a.Salary, a.AllAvgSalary\n        FROM (SELECT EmployeeID, Salary, AVG(Salary) OVER () AS AllAvgSalary \n              FROM EmployeeSalary) AS a\n        ORDER BY a.EmployeeID; 26",
    "Соединения без использования ключевого слова JOIN Использование неявных соединений, указывая несколько таблиц в разделе FROM и связывая с помощью WHERE",
    "-- Извлечение записей из таблиц inventory и sale путем сопоставления ID\n        SELECT * FROM inventory, sale\n        WHERE sale.inventoryid = inventory.inventoryid;\n        \n        -- Подсчет общей суммы с объединением таблиц\n        SELECT inventoryname, saledate, saleunitprice, salequantity,\n               salequantity * saleunitprice AS [Total Amount]\n        FROM sale, inventory\n        WHERE sale.inventoryid = inventory.inventoryid\n        GROUP BY sale.inventoryid, inventoryname, saledate, salequantity, saleunitprice; 27",
    "Разделение и обработка строк Использование SQL-функций для разделения строк по разделителям и обработки текстовых данных",
    "-- Разделение строк по запятой с использованием функций SUBSTRING, CHARINDEX и LEN\n        SELECT PropertyAddress,\n               SUBSTRING(PropertyAddress, 1, CHARINDEX(',', PropertyAddress) - 1) AS Address,\n               SUBSTRING(PropertyAddress, CHARINDEX(',', PropertyAddress) + 1, LEN(PropertyAddress)) AS City\n        FROM NashvilleHousing;\n        \n        -- Использование PARSENAME для разделения по точкам\n        SELECT OwnerAddress,\n               PARSENAME(REPLACE(OwnerAddress, ',', '.'), 3) AS AddressPart1,\n               PARSENAME(REPLACE(OwnerAddress, ',', '.'), 2) AS AddressPart2,\n               PARSENAME(REPLACE(OwnerAddress, ',', '.'), 1) AS AddressPart3\n        FROM NashvilleHousing; 28",
    "Удаление дубликатов записей Использование ROW_NUMBER и CTE для выявления и удаления дубликатов записей",
    "-- Использование ROW_NUMBER в CTE для идентификации дубликатов по определенным столбцам\n        WITH RowNumCTE AS (\n            SELECT *, \n                   ROW_NUMBER() OVER (PARTITION BY ParcelID, PropertyAddress, SalePrice, SaleDate, LegalReference \n                                      ORDER BY UniqueID) AS row_num\n            FROM NashvilleHousing\n        )\n        -- Выбор дубликатов для просмотра\n        SELECT * \n        FROM RowNumCTE\n        WHERE row_num > 1\n        ORDER BY PropertyAddress;\n        \n        -- Удаление дубликатов записей\n        DELETE FROM RowNumCTE\n        WHERE row_num > 1; 29",
    "Функции ранжирования SQL: RANK и DENSE_RANK Использование RANK и DENSE_RANK для присвоения рангов строкам внутри разделов",
    "-- Пример функции RANK для присвоения рангов на основе зарплаты с пропусками для совпадающих значений\n        SELECT *, \n               RANK() OVER (ORDER BY Salary DESC) AS SalaryRank\n        FROM EmployeeSalary;\n        \n        -- Пример DENSE_RANK без пропусков для совпадающих значений\n        SELECT *, \n               DENSE_RANK() OVER (ORDER BY Salary DESC) AS SalaryRank\n        FROM EmployeeSalary;\n        \n        -- Разделение по должностям для ранжирования RANK внутри каждой категории должностей\n        SELECT *, \n               RANK() OVER (PARTITION BY JobTitle ORDER BY Salary DESC) AS SalaryRank\n        FROM EmployeeSalary\n        ORDER BY JobTitle, SalaryRank; 30",
    "NTILE для группировки данных Использование NTILE для разделения результатов на указанное количество групп для анализа",
    "-- Функция NTILE для разделения сотрудников на 3 группы на основе зарплаты\n        SELECT *, \n               NTILE(3) OVER (ORDER BY Salary DESC) AS SalaryGroup\n        FROM EmployeeSalary;\n        \n        -- Разделение NTILE по должностям для деления зарплат на группы в каждой должности\n        SELECT *, \n               NTILE(3) OVER (PARTITION BY JobTitle ORDER BY Salary DESC) AS SalaryGroup\n        FROM EmployeeSalary\n        ORDER BY JobTitle, SalaryGroup; SQL Guide Полное руководство по SQL"
  ],
  "temp.html": [
    "Middleware в ASP.NET Core Middleware в ASP.NET Core Введение Конвейер Создание Middleware Middleware в ASP.NET Core Понимание Middleware и создание пользовательских компонентов в ASP.NET Core Введение В ASP.NET Core Middleware представляет собой компонент, который обрабатывает HTTP-запросы и может выполнять различные действия, такие как аутентификация, логирование, обработка ошибок, маршрутизация и многое другое",
    "Middleware компоненты обрабатывают запросы последовательно, формируя конвейер обработки запросов ",
    "Компоненты Middleware организованы в виде цепочки, где каждый компонент может передавать запрос следующему компоненту или завершить обработку",
    "Такое построение упрощает модульное добавление функций в приложение",
    "Конвейер обработки запросов Конвейер обработки запросов в ASP.NET Core состоит из последовательности компонентов Middleware",
    "Каждый компонент может выполнить действия до или после передачи управления следующему компоненту",
    "На изображении показан пример типичного конвейера запросов в ASP.NET Core, который включает такие компоненты, как обработка ошибок, сжатие ответов и маршрутизация",
    "Каждый компонент Middleware может решать, передавать ли запрос дальше или завершить его",
    "Создание пользовательского Middleware Чтобы создать собственный Middleware, можно создать класс с методом Invoke или InvokeAsync , который принимает HttpContext ",
    "Этот метод обрабатывает запрос и может вызывать следующий компонент конвейера",
    "public class CustomMiddleware\n{\n    private readonly RequestDelegate _next;\n\n    public CustomMiddleware(RequestDelegate next)\n    {\n        _next = next;\n    }\n\n    public async Task InvokeAsync(HttpContext context)\n    {\n        // Действие до следующего компонента\n        await context.Response.WriteAsync(\"Hello from custom middleware before!\\n\");\n\n        // Передача управления следующему компоненту\n        await _next(context);\n\n        // Действие после следующего компонента\n        await context.Response.WriteAsync(\"Hello from custom middleware after!\\n\");\n    }\n} Этот пример демонстрирует базовый Middleware, который выполняет действия до и после передачи запроса следующему компоненту в конвейере",
    "Чтобы подключить его к приложению, нужно зарегистрировать его в Startup.cs с помощью app.UseMiddleware<CustomMiddleware>() ",
    "Регистрация Middleware Для добавления Middleware в конвейер обработки запросов, его нужно зарегистрировать в методе Configure класса Startup с использованием методов UseMiddleware или специальных методов, таких как UseRouting , UseAuthorization и т.д",
    "public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    if (env.IsDevelopment())\n    {\n        app.UseDeveloperExceptionPage();\n    }\n\n    app.UseRouting();\n    app.UseAuthorization();\n\n    app.UseMiddleware<CustomMiddleware>();\n\n    app.UseEndpoints(endpoints =>\n    {\n        endpoints.MapControllers();\n    });\n} В этом примере сначала добавляются стандартные компоненты UseRouting и UseAuthorization , а затем пользовательский Middleware CustomMiddleware ",
    "Это определяет порядок обработки запросов",
    "Порядок вызова Middleware Порядок вызова Middleware в методе Configure важен, так как запросы обрабатываются по порядку",
    "Например, если вызвать UseAuthorization до UseRouting , авторизация не будет работать, так как маршруты ещё не настроены",
    "Компоненты, которые обрабатывают ответы (например, логирование), должны быть зарегистрированы ближе к началу, чтобы они могли отследить полный жизненный цикл запроса",
    "Потоки управления в Middleware Middleware может управлять потоком запроса, решая, передавать ли его следующему компоненту или завершить его",
    "Например, компонент аутентификации может завершить запрос, если пользователь не авторизован",
    "Компоненты также могут настраивать ответ до и после выполнения следующего Middleware, что позволяет гибко управлять жизненным циклом запросов",
    "Настройка CORS для ASP.NET Core CORS (Cross-Origin Resource Sharing) позволяет управлять доступом к вашему API из других доменов",
    "Это важно для защиты данных и предотвращения нежелательного доступа",
    "// Пример настройки CORS в ASP.NET Core\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddCors(options =>\n    {\n        options.AddPolicy(\"AllowSpecificOrigin\",\n            builder => builder.WithOrigins(\"https://specific-client.com\")\n                              .AllowAnyHeader()\n                              .AllowAnyMethod());\n    });\n}\npublic void Configure(IApplicationBuilder app)\n{\n    app.UseCors(\"AllowSpecificOrigin\");\n} В этом примере мы разрешаем доступ только для указанного домена",
    "Такая настройка обеспечивает безопасность при обмене данными между клиентом и сервером."
  ],
  "Value_Reference.html": [
    "Стек и Куча в C# Стек и Куча в C# Управление памятью Стек Куча GC Стек и Куча в C# Глубокое понимание управления памятью и сборки мусора Управление памятью в стеке и куче Стек Локальные переменные, ссылки на объекты",
    "LIFO (Last In, First Out) Автоматическое освобождение памяти",
    "Куча Объекты ссылочных типов: классы, строки, массивы",
    "Управляется сборщиком мусора (GC)",
    "Динамическое выделение памяти",
    "GC Автоматическое управление памятью",
    "Маркировка, очистка и компактизация объектов",
    "Работа с поколениями объектов",
    "Стек используется для хранения локальных переменных и ссылок на объекты",
    "Управляется по принципу LIFO ",
    "Куча хранит объекты ссылочных типов и управляется сборщиком мусора",
    "Эти механизмы позволяют эффективно управлять памятью и освобождать её при необходимости",
    "Стек В стеке хранятся: Локальные переменные значимых типов",
    "Параметры методов значимых типов",
    "Ссылки на объекты ссылочных типов",
    "Особенности стека: Работает по принципу LIFO (Last In, First Out)",
    "Имеет ограниченный размер (обычно около 1 МБ по умолчанию)",
    "Быстрый доступ к данным",
    "Память освобождается автоматически при выходе из области видимости",
    "Куча В куче хранятся: Объекты ссылочных типов",
    "Значимые типы внутри объектов ссылочных типов (поля классов)",
    "Массивы, независимо от того, содержат ли они значимые или ссылочные типы",
    "Закрытые переменные в замыканиях (лямбда-выражения, анонимные методы)",
    "Особенности кучи: Управляется сборщиком мусора (GC)",
    "Динамический размер, зависит от доступной памяти системы",
    "Более медленный доступ по сравнению со стеком",
    "Память освобождается сборщиком мусора, когда объекты становятся недостижимыми",
    "Принципы работы сборщика мусора (GC) Цели GC GC освобождает память автоматически, освобождая разработчика от ручного управления памятью",
    "Освобождение недостижимых объектов",
    "Обеспечение производительности и минимизация фрагментации памяти",
    "Алгоритм GC Маркировка: Помечаются все достижимые объекты",
    "Очистка: Удаляются объекты, не помеченные как достижимые",
    "Компактизация: Свободная память объединяется для улучшения её использования",
    "Поколения в GC Поколение Описание Поколение 0 Новые объекты, сборка мусора происходит чаще",
    "Поколение 1 Объекты, пережившие сборку мусора поколения 0",
    "Поколение 2 Долгоживущие объекты, сборка происходит реже",
    "Графическое представление стека и кучи Финализация объектов и интерфейс IDisposable Финализаторы Финализаторы используются для очистки неуправляемых ресурсов, но они увеличивают время жизни объектов и снижают производительность",
    "Предпочтительным является использование IDisposable и паттерна Dispose ",
    "Интерфейс IDisposable Позволяет разработчику явно освобождать ресурсы",
    "В C# удобно использовать блок using , который автоматически вызывает Dispose() ",
    "Практические рекомендации для оптимизации памяти Избегайте ручного вызова GC.Collect() , доверяя CLR",
    "Используйте IDisposable и using для освобождения ресурсов",
    "Профилируйте приложение для выявления утечек памяти",
    "Работа GC с большими объектами и LOH Объекты размером более 85 000 байт попадают в Large Object Heap (LOH), который не компактизируется",
    "Это может приводить к фрагментации памяти, и для оптимизации рекомендуется избегать частого создания и удаления крупных объектов",
    "Рекомендации для многопоточных приложений GC в .NET потокобезопасен, но разработчикам необходимо быть внимательными при работе с объектами, разделяемыми между потоками",
    "Использование слабых ссылок (Weak References) может помочь избежать удержания ненужных объектов в памяти",
    "2023 Стек и Куча в C#"
  ]
}